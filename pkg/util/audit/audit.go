package audit

import (
	"encoding/json"
	"fmt"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/Azure/ARO-RP/pkg/util/audit/schema"
	uuid "github.com/satori/go.uuid"
	"github.com/sirupsen/logrus"
)

const (
	auditMetadataCategory    = "auditCategory"
	auditMetadataCreatedTime = "auditCreatedTime"
	auditMetadataFullPayload = "auditFullPayload"
	auditMetadataLogKind     = "logKind"
	auditMetadataOperation   = "auditOperation"
	auditMetadataResult      = "auditResult"
	auditMetadataSource      = "auditSource"
	auditSourceRP            = "aro-rp"

	ifxAuditCloudVer = 1.0
	ifxAuditLogKind  = "ifxaudit"
	ifxAuditName     = "#Ifx.AuditSchema"
	ifxAuditVersion  = 2.1

	// ifxAuditFlags is a collection of values bit-packed into a 64-bit integer.
	// These properties describe how the event should be processed by the pipelinei
	// in an implementation-independent way.
	ifxAuditFlags = 257

	// ifxAuditPopSample is the effective percentage sample rate for this event at the
	// time it was generated by a client (either the default value specified in
	// the event definition, system default or a dynamic override from a cloud
	// settings service).
	// not used by Azure
	ifxAuditPopSample = 0.0
)

var (
	// epoch is an unique identifier associated with the current session of the
	// telemetry library running on the platform. It must be stable during a
	// session, and has no implied ordering across sessions.
	epoch string

	// sequence field used to track absolute order of uploaded events, per session.
	// it is reset when the ARO component is restarted.
	seqNum      uint64
	seqNumMutex *sync.Mutex
)

func init() {
	epoch = uuid.NewV4().String()
	seqNum = 1
	seqNumMutex = new(sync.Mutex)
}

// EmitRPLog is used by aro-rp to emit audit logs.
// Caller is responsible for providing the logrus.Entry object that contains
// the appropriate formatter, hooks, log level etc.
// All audit logs will be emitted at the INFO level.
func EmitRPLog(entry logrus.Entry, log *Log) error {
	return emitLog(entry, log, auditSourceRP)
}

func emitLog(entry logrus.Entry, log *Log, source string) error {
	payload := log.toPayload()

	fields := logrus.Fields{}
	fields[auditMetadataCategory] = payload.Category
	fields[auditMetadataCreatedTime] = time.Now().UTC().Format(time.RFC3339)
	fields[auditMetadataLogKind] = ifxAuditLogKind
	fields[auditMetadataOperation] = payload.OperationName
	fields[auditMetadataResult] = payload.Result.ResultType
	fields[auditMetadataSource] = source

	marshalled, err := marshal(payload)
	if err != nil {
		return err
	}
	fields[auditMetadataFullPayload] = marshalled

	// log message can be anything here, since the important audit data are
	// captured in the different log fields above.
	entry.WithFields(fields).Info("see auditFullPayload field for full log data")
	return nil
}

// Log captures information about the operation to be logged.
type Log struct {
	AzureEnvironment string
	CallerIdentities []*schema.CallerIdentity
	Category         schema.Category
	CorrelationID    string
	OperationID      string
	OperationName    string
	OperationResult  schema.Result
	Region           string
	Role             string
	RoleInstance     string
	TargetResources  []*schema.TargetResource
}

func (l *Log) toPayload() *schema.AuditPayload {
	utcnow := time.Now().UTC()
	payload := &schema.AuditPayload{
		// Part-A. See schema/doc.go
		EnvOS:                runtime.GOOS,
		EnvVer:               ifxAuditVersion,
		EnvName:              ifxAuditName,
		EnvTime:              utcnow.Format(time.RFC3339),
		EnvEpoch:             epoch,
		EnvSeqNum:            nextSeqNum(),
		EnvPopSample:         ifxAuditPopSample,
		EnvFlags:             ifxAuditFlags,
		EnvCV:                l.CorrelationID,
		EnvCloudVer:          ifxAuditCloudVer,
		EnvCloudName:         l.AzureEnvironment,
		EnvCloudRole:         l.Role,
		EnvCloudRoleInstance: l.RoleInstance,
		EnvCloudLocation:     l.Region,

		// Part-B. See schema/doc.go
		OperationName:    l.OperationName,
		Result:           l.OperationResult,
		Category:         l.Category,
		NCloud:           l.AzureEnvironment,
		RequestID:        l.OperationID,
		CallerIdentities: l.CallerIdentities,
		TargetResources:  l.TargetResources,
	}

	return payload
}

// marshal converts the payload into JSON format compatible with IFxAudit
// formatting requirement. E.g., empty strings are replaced with nulls.
func marshal(payload *schema.AuditPayload) (string, error) {
	b, err := json.Marshal(payload)
	if err != nil {
		return "", fmt.Errorf("%s", err)
	}

	// IFxAudit wants nulls not empty string values
	return strings.Replace(string(b), `""`, `null`, -1),
		err
}

func nextSeqNum() uint64 {
	seqNumMutex.Lock()
	defer seqNumMutex.Unlock()

	return seqNum + 1
}
